#!/bin/perl


##
##This script reads a config file, which describes a list
##of files in order. It then reads those files and parses them
##for comments matching spcified patterns. The combination of
##parsed comments, plus extra info pulled from the config file
##is combined into a single output stream.
##

# Basic perl includes
use strict;
use JSON;
use DateTime;
use Getopt::Long;
use Data::Dumper;
use Env;
use List::MoreUtils qw(uniq);

##The comment-doc script uses a number of global variables that can be overridden with command ;ine options. These options are as follows:
##- --config: This is the configuration. It is an object, with specific headers and a list of files.
my $config;
##- --headers: This determines whether to display pandoc markdown headers. The default is no.
my $headers = 0;
##- --output: This defaults to stdout, but can be used to store items in a file.
my $output_filename = "/dev/stdout";

##
##Default config files. This is a list of default config files in order of precedence: ./.comment-doc.json, $HOME/.comment-doc.json, and /etc/comment-doc.json.
my @config_filenames = ("./.comment-doc.json", "$HOME/.comment-doc.json", "/etc/comment-doc.json" );

my $custom_config = "";

# These will be added later
my $input = "/dev/stdin";
my $start_line = '^';
my $end_line = "\cD";
my $include_marker = "^";
my @output_filenames;
my @outputs;

##
##The configuration file must be correctly formatted json passed at the command line
##or loaded from a config file.
sub read_config {
    my $config_object;
    my $config_file;
    my $config_text;
    
    ##The script first checks to see if a config has been passed
    ##at the command line.
    if($custom_config ne ""){
        ##If it has, it tries to open the file name or parses the 
        ##string as JSON and returns without trying to open a config file.
        open($config_file, "<", $custom_config) or
        ($config_object = decode_json $custom_config and
        return validate_config($config_object));
    }
    ##If no special config is found, it tries to open and read the configuration files in order.
    else {
        ##
        foreach my $config_filename (@config_filenames){
            ##As soon as it opens a config file successfully, it uses it, and ignores the other files.
            open($config_file, "<", $config_filename) and last ;
        }
    }

    while(<$config_file>) {
        $config_text .= $_;
    }
    #If all configs are empty, it sets a default empty config and uses that.
    if ($config_text eq ""){
        $config_text = '{}';
    }
    
    ##It either case, it converts the JSON to a $config object and validates it.
    $config_object = decode_json $config_text;
    
    return validate_config($config_object);
}

##
##The configuration validation ensures that a complete
##configuration is present with default values if necessary.
sub validate_config {
    my $config_object = shift;

    if(!defined $config_object->{defaults}->{file_name}){
        $config_object->{defaults}->{file_name} = $input;
    }
    if(!defined $config_object->{defaults}->{pre_lines}){
        $config_object->{defaults}->{pre_lines} = [ "" ];
    }
    elsif(ref($config_object->{defaults}->{pre_lines}) ne 'ARRAY'){
        die "Error: the pre_lines element must be an array";
    }
    if(!defined $config_object->{defaults}->{post_lines}){
        $config_object->{defaults}->{post_lines} = [ "" ];
    }
    elsif(ref($config_object->{defaults}->{post_lines}) ne 'ARRAY'){
        die "Error: the post_lines element must be an array";
    }
    if(!defined $config_object->{defaults}->{start_line}){
        $config_object->{defaults}->{start_line} = $start_line;
    }
    if(!defined $config_object->{defaults}->{end_line}){
        $config_object->{defaults}->{end_line} = $end_line;
    }
    if(!defined $config_object->{defaults}->{include_marker}){
        $config_object->{defaults}->{include_marker} = $include_marker;
    }
    if(!defined $config_object->{defaults}->{output}){
        $config_object->{defaults}->{output} = $output_filename;
    }
    if(!defined $config_object->{headers}->{title}){
        $config_object->{headers}->{title} = "";
    }
    if(!defined $config_object->{headers}->{author}){
        $config_object->{headers}->{author} = "";
    }
    if(!defined $config_object->{headers}->{date}){
        $config_object->{headers}->{date} = DateTime->now->ymd;
    }
    if((defined $config_object->{files}) and (ref($config_object->{files}) ne 'ARRAY')){
            die "Error: the files element must be an array";
    }
    for ( @{$config_object->{files}} ) {
        if(!defined $_->{file_name}){
            $_->{file_name} = $config_object->{defaults}->{file_name};
        }
        if(!defined $_->{pre_lines}){
            $_->{pre_lines} = $config_object->{defaults}->{pre_lines};
        }
        elsif(ref($_->{pre_lines}) ne 'ARRAY'){
            die "Error: the pre_lines element must be an array";
        }
        if(!defined $_->{post_lines}){
            $_->{post_lines} = $config_object->{defaults}->{post_lines};
        }
        elsif(ref($_->{post_lines}) ne 'ARRAY'){
            die "Error: the post_lines element must be an array";
        }
        if(!defined $_->{start_line}){
            $_->{start_line} = $config_object->{defaults}->{start_line};
        }
        if(!defined $_->{end_line}){
            $_->{end_line} = $config_object->{defaults}->{end_line};
        }
        if(!defined $_->{include_marker}){
            $_->{include_marker} = $config_object->{defaults}->{include_marker};
        }
        if(!defined $_->{output}){
            $_->{output} = $config_object->{defaults}->{output};
        }
    }
        
    return $config_object;
}

##
##The script reads each file in the list in order and returns
##the comments extracted at the end.
sub read_input_file {
    my $input_file_config = shift;
    
    open(my $input_file, "<", $input_file_config->{file_name}) or die "Can't open $input_file_config->{file_name}";
    
    my $extracted_comments;
    
    ##For each file, it first inserts the configured `pre_lines`
    ##that precede the file contents, such as metadata about the file
    ##or lines including an entire block of code.
    for(@{$input_file_config->{pre_lines}}){
        ##This step is skipped only if the `pre_lines` are empty.
        if( !/^$/){
            $extracted_comments .= $_ . "\n";
        }
    }
    
    ##
    my $search_for_comments = 1;
    
    ##The script then reads the file.
    while(<$input_file>) {
        ##If it finds a special `start_line`, it will begin searching for comments.
        ##By default the `start_line` is set to match any line.
        if( /$input_file_config->{start_line}/) {
            $search_for_comments = 0;
        }
        if($search_for_comments == 0){
            ##If it finds a comment delineated by the `include_marker`,
            ##it removes the `include_marker` and adds the comment to the list
            if( /$input_file_config->{include_marker}/) {
                s/$input_file_config->{include_marker}//;
                $extracted_comments .= $_;
            }
        }
        ##It also checks for a special `end_line`, which will stop it from finding further comments.
        if( /$input_file_config->{end_line}/) {
            $search_for_comments = 1;
            last;
        }
    }
    ##Finally, it appends `post_lines` as it did with the `pre_lines`.
    for(@{$input_file_config->{post_lines}}){
        if( !/^$/){
            $extracted_comments .= $_ . "\n";
        }
    }
    
    close $input_file;
    
    return $extracted_comments;
}





GetOptions( 'headers' => \$headers, 'output=s' => \$output_filename, 'config=s' => \$custom_config );

$config = read_config;

#print Dumper $config;

for ( @{$config->{files}} ) {
    push @output_filenames, $_->{output};
}
@output_filenames = uniq @output_filenames;
for my $filename (@output_filenames){
    my $file->{name} = $filename;
    push @outputs, $file;
}

#print Dumper @outputs;

for my $output (@outputs){
    $output->{string} = "";
    
    if($headers == 1){
        $output->{string} .= '%' . $config->{headers}->{title} . "\n";
        $output->{string} .= '%' . $config->{headers}->{author} . "\n";
        $output->{string} .= '%' . $config->{headers}->{date} . "\n\n";
    }
    
    foreach my $file ( @{$config->{files}} ) {
        if($output->{name} eq $file->{output}){
            $output->{string} .= read_input_file $file;
        }
    }

        
    ##
    ##The output can be written to an output file or to stdout.
    ##
    open(my $output_file, ">", $output->{name}) or die "Unable to open $output->{name}";
        
        print $output_file $output->{string};
    }

# 
# else{
#     print $output;
# }


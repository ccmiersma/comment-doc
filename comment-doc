#!/bin/perl


##
##This script reads a config file, which describes a list
##of files in order. It then reads those files and parses them
##for comments matching specified patterns. The combination of
##parsed comments, plus extra info pulled from the config file
##is combined into a single output stream.
##

# Basic perl includes
use strict;
use JSON;
use DateTime;
use Getopt::Long;
use Data::Dumper;
use Env;
use List::MoreUtils qw(uniq);

##The comment-doc script uses a number of global variables that can be overridden with command ;ine options. These options are as follows:
##- --config: This is the configuration. It is an object, with specific headers and a list of files.
my $config;
##- --debug: This determines whether to dump certain variables for debugging. The default is no.
my $debug = 0;
##- --headers: This determines whether to display pandoc markdown headers. The default is no.
my $headers = 0;
##- --output: This defaults to stdout, but can be used to store items in a file.
my $output = "/dev/stdout";

##
##Default config files. This is a list of default config files in order of precedence: ./.comment-doc.json, $HOME/.comment-doc.json, and /etc/comment-doc.json.
my @config_filenames = ("./.comment-doc.json", "$HOME/.comment-doc.json", "/etc/comment-doc.json" );

my $custom_config = "";

# These will be added later
my $input = "/dev/stdin";
my $begin = '^';
my $end = "\cD";
my $include_marker = "^";
my @outputs;
my @out_buffers;

GetOptions( 'headers' => \$headers, 'debug' => \$debug,  'output=s' => \$output, 'config=s' => \$custom_config );

##
##The configuration file must be correctly formatted json passed at the command line
##or loaded from a config file.
sub read_config {
    my $config_object;
    my $config_file;
    my $config_text;
    
    ##The script first checks to see if a config has been passed
    ##at the command line.
    if($custom_config ne ""){
        ##If it has, it tries to open the file name or parses the 
        ##string as JSON and returns without trying to open a config file.
        open($config_file, "<", $custom_config) or
        ($config_object = decode_json $custom_config and
        return validate_config($config_object));
    }
    ##If no special config is found, it tries to open and read the configuration files in order.
    else {
        ##
        foreach my $config_filename (@config_filenames){
            ##As soon as it opens a config file successfully, it uses it, and ignores the other files.
            open($config_file, "<", $config_filename) and last ;
        }
    }

    while(<$config_file>) {
        $config_text .= $_;
    }
    #If all configs are empty, it sets a default empty config and uses that.
    if ($config_text eq ""){
        $config_text = '{}';
    }
    
    ##It either case, it converts the JSON to a $config object and validates it.
    $config_object = decode_json $config_text;
    
    return validate_config($config_object);
}

##
##The configuration validation ensures that a complete
##configuration is present with default values if necessary.
sub validate_config {
    my $config_object = shift;

    if(!defined $config_object->{defaults}->{input}){
        $config_object->{defaults}->{input} = $input;
    }
    if(!defined $config_object->{defaults}->{pre_lines}){
        $config_object->{defaults}->{pre_lines} = [ "" ];
    }
    elsif(ref($config_object->{defaults}->{pre_lines}) ne 'ARRAY'){
        die "Error: the pre_lines element must be an array";
    }
    if(!defined $config_object->{defaults}->{post_lines}){
        $config_object->{defaults}->{post_lines} = [ "" ];
    }
    elsif(ref($config_object->{defaults}->{post_lines}) ne 'ARRAY'){
        die "Error: the post_lines element must be an array";
    }
    if(!defined $config_object->{defaults}->{begin}){
        $config_object->{defaults}->{begin} = $begin;
    }
    if(!defined $config_object->{defaults}->{end}){
        $config_object->{defaults}->{end} = $end;
    }
    if(!defined $config_object->{defaults}->{include_marker}){
        $config_object->{defaults}->{include_marker} = $include_marker;
    }
    if(!defined $config_object->{defaults}->{output}){
        $config_object->{defaults}->{output} = $output;
    }
    if(!defined $config_object->{headers}->{title}){
        $config_object->{headers}->{title} = "";
    }
    if(!defined $config_object->{headers}->{author}){
        $config_object->{headers}->{author} = "";
    }
    if(!defined $config_object->{headers}->{date}){
        $config_object->{headers}->{date} = DateTime->now->ymd;
    }
    if((defined $config_object->{inputs}) and (ref($config_object->{inputs}) ne 'ARRAY')){
            die "Error: the inputs element must be an array";
    }
    for ( @{$config_object->{inputs}} ) {
        if(!defined $_->{input}){
            $_->{input} = $config_object->{defaults}->{input};
        }
        if(!defined $_->{pre_lines}){
            $_->{pre_lines} = $config_object->{defaults}->{pre_lines};
        }
        elsif(ref($_->{pre_lines}) ne 'ARRAY'){
            die "Error: the pre_lines element must be an array";
        }
        if(!defined $_->{post_lines}){
            $_->{post_lines} = $config_object->{defaults}->{post_lines};
        }
        elsif(ref($_->{post_lines}) ne 'ARRAY'){
            die "Error: the post_lines element must be an array";
        }
        if(!defined $_->{begin}){
            $_->{begin} = $config_object->{defaults}->{begin};
        }
        if(!defined $_->{end}){
            $_->{end} = $config_object->{defaults}->{end};
        }
        if(!defined $_->{include_marker}){
            $_->{include_marker} = $config_object->{defaults}->{include_marker};
        }
        if(!defined $_->{output}){
            $_->{output} = $config_object->{defaults}->{output};
        }
    }
        
    return $config_object;
}


##
##The script reads each file in the list in order and returns
##the comments extracted at the end.
sub read_input_file {
    my $input_file_config = shift;
    
    open(my $input_file, "<", $input_file_config->{input}) or die "Can't open $input_file_config->{input}";
    
    my $extracted_comments;
    
    ##For each file, it first inserts the configured `pre_lines`
    ##that precede the file contents, such as metadata about the file
    ##or lines including an entire block of code.
    for(@{$input_file_config->{pre_lines}}){
        ##This step is skipped only if the `pre_lines` are empty.
        if( !/^$/){
            $extracted_comments .= $_ . "\n";
        }
    }
    
    ##
    my $search_for_comments = 1;
    
    ##The script then reads the file.
    while(<$input_file>) {
        ##If it finds a special `begin` regexp, it will begin searching for comments.
        ##By default `begin` is set to match any line.
        if( /$input_file_config->{begin}/) {
            $search_for_comments = 0;
        }
        if($search_for_comments == 0){
            ##If it finds a comment delineated by the `include_marker`,
            ##it removes the `include_marker` and adds the comment to the list
            if( /$input_file_config->{include_marker}/) {
                s/$input_file_config->{include_marker}//;
                $extracted_comments .= $_;
            }
        }
        ##It also checks for a special `end` regexp, which will stop it from finding further comments.
        if( /$input_file_config->{end}/) {
            $search_for_comments = 1;
            last;
        }
    }
    ##Finally, it appends `post_lines` as it did with the `pre_lines`.
    for(@{$input_file_config->{post_lines}}){
        if( !/^$/){
            $extracted_comments .= $_ . "\n";
        }
    }
    
    close $input_file;
    
    return $extracted_comments;
}

sub debug {
    if ($debug == 1){
        print Dumper shift;
    }
}

$config = read_config;

debug $config;

# For each input, add it's output to the outputs
for ( @{$config->{inputs}} ) {
    push @outputs, $_->{output};
}

# Reduce to unique outputs
@outputs = uniq @outputs;

# Convert outputs to out buffers, with name and later a content string.
for my $filename (@outputs){
    my $file->{name} = $filename;
    push @out_buffers, $file;
}

# Process the out_buffers, add a string to hold the contents to each and fill it.
for my $out_buffer (@out_buffers){
    $out_buffer->{string} = "";
    
    # If we want headers, add them to the string
    if($headers == 1){
        $out_buffer->{string} .= '%' . $config->{headers}->{title} . "\n";
        $out_buffer->{string} .= '%' . $config->{headers}->{author} . "\n";
        $out_buffer->{string} .= '%' . $config->{headers}->{date} . "\n\n";
    }
    
    # For each input, if it matches the current output process the file.
    foreach my $file ( @{$config->{inputs}} ) {
        if($out_buffer->{name} eq $file->{output}){
            $out_buffer->{string} .= read_input_file $file;
        }
    }

        
    ##
    ##The output can be written to an output file or to stdout.
    ##
    # Open the file for writing.
    open(my $output_file, ">", $out_buffer->{name}) or die "Unable to open $out_buffer->{name}";
    
    debug $out_buffer;
    
    # Add the string to the file.
    print $output_file $out_buffer->{string};
}

